#!/usr/bin/python

WIDTH = 800
HEIGHT = 300
FS = False
TITLE = "Virtual Keyboard"
WM_INFO = ("Virtual Keyboard", "vkbd")

import virtkey
import os
import sys
import evas
import evas.decorators
import edje
import edje.decorators
import ecore
import ecore.evas
import ecore.x
import dbus
import e_dbus
import dbus.service

''' virtkey '''
v = virtkey.virtkey()

def on_resize(ee):
    x, y, w, h = ee.evas.viewport
    ee.data["main"].size = w, h


def on_delete_request(ee):
    ecore.main_loop_quit()


def on_key_down(obj, event, ee):
    if event.keyname in ("F6", "f"):
        ee.fullscreen = not ee.fullscreen
    elif event.keyname == "Escape":
        ecore.main_loop_quit()

'''  Dbus  Object  '''
class VkbdToggleObject(dbus.service.Object):
    def __init__(self, conn, object_path="/com/vkbd/Toggle/toggle"):
        dbus.service.Object.__init__(self, conn, object_path)
        self.state = 1

    @dbus.service.signal("com.vkbd.Toggle")
    def ToggleSignal(self, message):
        # The signal is emitted when this method exits
        # You can have code here if you wish
        pass

    @dbus.service.method("com.vkbd.Toggle")
    def Show(self):
        ee.show()
        self.state = 1
        self.ToggleSignal("Show")    
        return "Vkbd show"
        
    @dbus.service.method("com.vkbd.Toggle")
    def Hide(self):
        ee.hide()
        self.state = 0
        self.ToggleSignal("Hidden")       
        return "Vkbd hide"
        
    @dbus.service.method("com.vkbd.Toggle")
    def GetState(self):       
        return self.state

    @dbus.service.method("com.vkbd.Toggle",
                         in_signature="", out_signature="")
    def Exit(self):
        ecore.idler_add(ecore.main_loop_quit)



class VirtualKeyboard(edje.Edje):
    def __init__(self, canvas):
        edje.Edje.__init__(self, canvas)
        self.text = []
        f = os.path.splitext(sys.argv[0])[0] + ".edj"
        self.file_set(f, "main")
        self.obj = {
            "alpha": self.part_swallow_get("alpha"),
            "special-1": self.part_swallow_get("special-1"),
            "special-2": self.part_swallow_get("special-2"),
            }
        self.pressed_keys = {}
        self.is_shift_down = False
        self.is_mouse_down = False
        self.is_cn_down = False

	'''   Shift Toggle  '''
    def press_shift(self):
        self.obj["alpha"].signal_emit("press_shift", "")
        v.lock_mod(1)
        self.is_shift_down = True

    def release_shift(self):
        self.obj["alpha"].signal_emit("release_shift", "")
        v.unlock_mod(1)
        self.is_shift_down = False

    def toggle_shift(self):
        if self.is_shift_down:
            self.release_shift()
        else:
            self.press_shift()

	"""    CN Toggle    """            
    def press_cn(self):
        self.obj["alpha"].signal_emit("press_fcitx", "")
        self.is_cn_down = True

    def release_cn(self):
        self.obj["alpha"].signal_emit("release_fcitx", "")
        self.is_cn_down = False

    def toggle_cn(self):
        if self.is_cn_down:
            self.release_cn()
        else:
            self.press_cn()

    @edje.decorators.signal_callback("key_down", "*")
    def on_edje_signal_key_down(self, emission, source):
    	#print source
        if ':' in source:
            part, key = source.split(":", 1)
        else:
            key = source
        if key == "enter":
			v.press_keycode(36)
			v.release_keycode(36)
            #self.press_shift()
        elif key == "@":
			v.press_keysym(0x40)
			v.release_keysym(0x40)
        elif key == "backspace":
			v.press_keycode(22)
			v.release_keycode(22)
        elif key == "space":
			v.press_keycode(65)
			v.release_keycode(65) 
        elif key == "up":
			v.press_keycode(111)
			v.release_keycode(111)
        elif key == "tab":
			v.press_keycode(23)
			v.release_keycode(23)            
        elif key == "shift":
            self.toggle_shift()
        elif key == "fcitx":
            self.toggle_cn()
        elif key in (".?123", "ABC", "#+=", ".?12"):
            pass
        elif "0x" in key:
        	v.press_keysym(int(key, 16))
        	v.release_keysym(int(key, 16))
        else:
			v.press_keycode(int(key))
			v.release_keycode(int(key))

    @edje.decorators.signal_callback("mouse_over_key", "*")
    def on_edje_signal_mouse_over_key(self, emission, source):
        if not self.is_mouse_down:
            return
        if ':' not in source:
            return
        part, subpart = source.split(':', 1)
        o = self.obj[part]

        if subpart in self.pressed_keys:
            return

        for k in self.pressed_keys.values():
            o.signal_emit("release_key", k)
        self.pressed_keys.clear()
        self.pressed_keys[subpart] = subpart
        o.signal_emit("press_key", subpart)

    @edje.decorators.signal_callback("mouse_out_key", "*")
    def on_edje_signal_mouse_out_key(self, emission, source):
        if not self.is_mouse_down:
            return
        if ':' not in source:
            return
        part, subpart = source.split(':', 1)
        o = self.obj[part]

        if subpart in self.pressed_keys:
            del self.pressed_keys[subpart]
            o.signal_emit("release_key", subpart)


    @edje.decorators.signal_callback("mouse,down,1", "*")
    def on_edje_signal_mouse_down_key(self, emission, source):
        if ':' not in source:
            return
        part, subpart = source.split(':', 1)
        o = self.obj[part]
        self.is_mouse_down = True

        if subpart in self.pressed_keys:
            return

        for k in self.pressed_keys.values():
            o.signal_emit("release_key", k)
        self.pressed_keys.clear()
        self.pressed_keys[subpart] = subpart
        o.signal_emit("press_key", subpart)

    @edje.decorators.signal_callback("mouse,down,1,*", "*")
    def on_edje_signal_mouse_down_multiple_key(self, emission, source):
        self.on_edje_signal_mouse_down_key(self, emission, source)

    @edje.decorators.signal_callback("mouse,up,1", "*")
    def on_edje_signal_mouse_up_key(self, emission, source):
    	#print source
        if ':' not in source:
            return
        part, subpart = source.split(':', 1)
        o = self.obj[part]
        self.is_mouse_down = False
        if subpart in self.pressed_keys:
            del self.pressed_keys[subpart]
            o.signal_emit("release_key", subpart)
            o.signal_emit("activated_key", subpart)

    @evas.decorators.mouse_down_callback
    def on_mouse_down(self, event):
        if event.button != 1:
            return
        self.is_mouse_down = True

    @evas.decorators.mouse_up_callback
    def on_mouse_up(self, event):
        if event.button != 1:
            return
        self.is_mouse_down = False

    @evas.decorators.key_down_callback
    def on_key_down(self, event):
        k = event.keyname.lower()
        if k == "return":
            k = "enter"
        elif k == "backspace":
            pass
        elif k.startswith("shift"):
            k = "shift"
        elif k.startswith("alt_"):
            return
        elif k.startswith("control_"):
            return
        else:
            k = event.string

        if k:
            o.signal_emit("key_down", k)



dbus_ml = e_dbus.DBusEcoreMainLoop()
session_bus = dbus.SessionBus(mainloop=dbus_ml)


if ecore.evas.engine_type_supported_get("software_16_x11") and \
   '-x11' not in sys.argv:
    ee = ecore.evas.SoftwareX11(w=WIDTH, h=HEIGHT)
else:
    ee = ecore.evas.SoftwareX11(w=WIDTH, h=HEIGHT)
    
name = dbus.service.BusName("com.vkbd.Toggle", session_bus)
obj = VkbdToggleObject(session_bus)

ex = ecore.x.Window_from_xid(ee.window_get())
ex.icccm_hints_set(0, 1, 0, 0, 0, 0, 0)
"""  shape the window  """
ee.shaped_set(1)

canvas = ee.evas
o = VirtualKeyboard(canvas)
o.size = canvas.size
o.focus = True
o.show()
o.on_key_down_add(on_key_down, ee)


ee.data["main"] = o
ee.callback_delete_request = on_delete_request
ee.callback_resize = on_resize
ee.title = TITLE
ee.name_class = WM_INFO
ee.fullscreen = FS
ee.move(0, 280)
ee.show()
ex.show()

ecore.main_loop_begin()
